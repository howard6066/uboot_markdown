#Uboot 2
----------------------------

##2.1 总结回顾
> lowlevel_init.S 总共做了哪些事情：
+ 检查复位状态、IO恢复、关看门狗、开发板供电锁存、时钟初始化、DDR初始化、串口初始化并打印"O",tzpc_init。打印"K"

##2.2 再次设置栈（DDR中的栈）
> 因为之前是在SRAM中，栈也是在SRAM中，而此时已经初始化完DDR，因此要把栈重新设在DDR中。这是第二次设置栈。


##2.3 再次判断当前地址以是否决定要重定位。
> 再次判断运行地址是在SRAM中还是在DDR中，上次判断是为了决定是否要执行初始化时钟中的DDR。而这次判断是为了决定是否要进行uboot中的relocate.

+ 冷启动时当前情况是uboot的前一部分（16KB或者8KB）开机自动从SD卡加载到SRAM中，uboot的第二部分（其实是整个uboot）还在SD卡的某个扇区开头的N个扇区。至此，uboot第一阶段即将结束，结束之前要把第二部分加载到DDR中的链接地址处（33e00000）,这个加载过程就叫做重定位。

##2.4 重定位
> D0037488 这个内存地址在SRAM中，这个地址里的值是被硬件自动设置的。用来判断启动类型
1. 0xEB200000 --> mmc
2. movi_bl2_copy

##2.5 虚拟地址、物理地址
> 虚拟地址映射层，依赖与映射表把虚拟地址转换位物理地址。

##2.6 MMU单元的作用
> memory management unit .MMU是SOC中的一个硬件单元。主要功能是实现虚拟地址到物理地址的映射。
+ MMU在CP15协处理器中进行控制。

##2.7 地址映射的额外收益
1. 访问控制
2. 快速缓存。比CPU慢，比DDR块。

##2.8CP15寄存器
1.c2 寄存器
> TTB ->translation table base 转换表基地址。包括表索引和表项，在ARM中支持3中块大小，分别是1KB（细表）、4KB（粗表），1MB（段表）。转换表放置在内存中的，转换表不需要软件干涉，而是将基地址TTB设置到c2寄存器中，然后MMU工作的时候回自动去查找转换表。

2.c3 寄存器
> 域访问控制器

3.c1 寄存器
> C1寄存器的bit0 控制MMU的开关，只要将这个位置1 即可。

##2.9 索引表
> 转换表可以看做是一个int类型的数组。ARM的段映射需要4096个单元。实际上我们并没有依次处理这个4096个单元，而是把4096个分成几个部分循环处理。
```Assembly
.macro FL_SECTION_ENTRY base,ap,d,c,b
	.word (\base << 20) | (\ap << 10) | \
	      (\d << 5) | (1<<4) | (\c << 3) | (\b << 2) | (1<<1)
.endm
// Access for iRAM
.rept 0x100
FL_SECTION_ENTRY __base,3,0,0,0
.set __base,__base+1
.endr
```

+ 虚拟地址映射只是把虚拟地址的c0000000开头的256MB映射到DMC0de 30000000开头的256MB的物理内存上去。其他的虚拟地址空间没有做改变。因此配置时将链接地址设置为c3e00000,因为这个地址会被映射为33e00000

##2.10 第三次设置栈
> 还是在DDR中，之前虽然已经在DDR中设置过栈，但是本次设置栈的目的是将栈设置在合适的地方（安全，紧凑而不浪费内存）
+ 我们实际将栈设置在uboot上方2MB处，这样安全的栈空间为2MB-uboot大小-0x100=1.8MB左右

##2.11 清理BSS
> 如同裸机中的代码一致，

##2.12 _start_armboot
> start_armboot是uboot的第二阶段

```
ldr	pc, _start_armboot
```
+ 远跳转SRAM--> DRAM

回顾： uboot第一阶段做了哪些工作
1. 构建异常向量表
2. 设置CPU SVC模式
3. lowlevel_init,关看门狗，
4. 开发板供电置锁
5. 时钟初始化
6. DDR初始化
7. 串口初始化
8. 重定位
9. 建立映射表，开启MMU
10. 跳转到第二阶段
